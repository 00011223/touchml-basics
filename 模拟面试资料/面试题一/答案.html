<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        /* 二 css部分 */

        /* 1. 块级元素独占一整行，可以设置任意盒子模型的属性
            行内元素，不独占一行，且margin和padding只有水平方向生效，width和height无法决定内容大小，内容大小由标签中的内容决定
        */

        /* 2. position:
            relative; 
            absolute;
            fixed;
            sticky;
        */

        /* 3.
            id选择器
            class选择器
            标签选择器
            后代   div ul li
            子代   div>ul>li
            属性
            兄弟   div+span div~span
        */

        /* 4.
            overflow
            auto
            hidden
            scroll
        */

        /* 
            5. 居中方法
            1. flex
            2. position 配合 calc 计算函数
        */
    </style>
</head>

<body>
    <!-- 一 html部分 -->
    <!-- 1. 块级元素 -->
    <div></div>
    <h1></h1>
    <p></p>
    <ul></ul>
    <ol></ol>
    <table></table>
    <!-- 1. 行内元素 -->
    <b></b>
    <u></u>
    <i></i>
    <span></span>
    <a href=""></a>
    <strong></strong>
    <del></del>

    <!-- 2.
        title 鼠标悬停在图片上始终显示
        alt 图片加载失败时显示的替代文本
    -->
    <img src="./img/Snipaste_2022-04-12_15-40-05.png" title="这是title" alt="这是alt">
    <img src="" title="这是title" alt="这是alt">

    <!-- 3. 
        target 指定跳转的页面是哪一个
        _self 当前页面
        _blank 新开页面
        target 还可以填 iframe 的 name 属性，作用是让指定的 iframe 跳转
    -->
    <a href="" target="_self"></a>

    <!-- 4. 
        使用场景：内嵌一个外部系统的子页面，例如：集成一个百度地图，百度地图作为子页面有独立的页面的作用域，不会干扰页面的其他元素
        优点：类似一个sandbox沙箱，沙箱环境中的页面发生任何异常或写入任何样式，都不会影响父页面
        缺点：受跨域政策的影响，并非所有页面都能使用 iframe 进行内嵌
    -->

    <iframe src="https://www.baidu.com" frameborder="0"></iframe>
    <iframe src="abc" frameborder="0"></iframe>
    <iframe src="abc" frameborder="0"></iframe>
    <!-- 5. https://www.cnblogs.com/jane-panyiyun/p/13092297.html -->


</body>
<script>
    // 三 js 部分
    // 1.
    document.querySelector
    document.querySelectorAll
    document.getElementById
    document.getElementsByClassName
    document.getElementsByTagName

    // 2.
    let arr = [1, 2, 3, 4]
    arr.splice(1, 1) // 删除指定索引位置的成员
    console.log(arr);
    // let r = arr.slice(1)
    let r = arr.slice(0, 2) // 数组切片，用于截取子数组
    console.log(r);

    // 3.
    // === 严格相等，包括类型和值都相等
    // == 值相等，类型可以互相之间进行隐式转换

    // 4.
    // cookie 是由服务器在浏览器上设置的参数
    // sessionStorage 和 localStorage 是浏览器设置的参数
    // localStorage 数据持久化，将一直存在于浏览器中
    // sessionStorage 会随着会话的结束而消失


    // 5.
    // request url: 请求地址
    // status code: 状态码
    // request method: 请求方法
    // access-control-allow-origin: 允许访问的跨域源
    // content-type: 请求数据的类型
    // content-length: 内容长度
    // user-agent: 用户代理信息
    // cookie: 请求自动携带的 cookie

    // 6.
    // setup
    // beforeCreate
    // created    ajax 此时页面还未渲染 可以提前发送请求
    // beforeMount
    // mounted    ajax 此时页面渲染完成，可以让页面先显示占位符，然后发送请求 请求真实数据
    // beforeUpdate
    // updated
    // beforeUnmount
    // unmounted                          

    // ajax (async javascript and xml)
    // ajax 意思是: 异步的网络请求


    // 四: 程序题
    // 1.
    // -> 20
    // -> 20
    // -> 30
    // -> 40


    // 2.
    (function f(f) {
        return typeof f() // -> string
    })(function () {
        return '1'
    })

    // 3. 数组去重和排列
    let arr2 = [5, 2, 3, 6, 8, 6, 5, 4, 7, 1, 9]
    // let temp = {}

    // arr2 = arr2.filter(item => {
    //     // 判断 数组成员是否存在于缓存 temp 中
    //     let r = temp[item]
    //     // 若已存在就过滤掉
    //     if (r) return false
    //     else {
    //         // 若不存在就加入缓存
    //         temp[item] = true
    //         return true
    //     }
    // })

    // Set 是一个不会重复的集合
    let set = new Set(arr2)
    // 转换set成数组
    arr2 = Array.from(set)

    console.log(set);

    console.log(arr2);

    arr2.sort((item1, item2) => {
        if (item1 > item2) {
            // <
            // 返回小于零的数，代表将item1放到item2的左侧
            return -1
        } else if (item1 < item2) {
            // >
            // 返回大于零的数，代表将item1放到item2的右侧
            return 1
        } else {
            // 返回 0 代表顺序不变
            return 0
        }
    })
    console.log(arr2);
</script>

</html>